3PSK Specification
---- -------------

Versioning:
This is version 0.2, dated 26th September 2010.
Prepared by Edward Cree M0TBK (previously M3TBK).

Abstract:
The author presents a modified form of PSK (Phase Shift Keying), a popular mode for textual conversation over radio links (especially Amateur Radio), and gives details of its implementation.

Rationale:
BPSK31 (also known as "Varicode", properly its encoding alphabet), the data mode developed by Peter Martinez [G3PLX], has many advantages which make it widely used in the Amateur Radio community and elsewhere; these include its narrow bandwidth (and consequent resilience in weak-signal or noisy conditions) and simplicity of operation.  However, the baud rate must be agreed beforehand by all parties in the conversation, and is generally fixed by convention at 31.25 baud.  Also, it is necessary for the receiving station to recover the clock signal by means of a phase-locked loop, and since not every bit involves a reversal, an error can cascade for several symbols or even characters before it is corrected.  While these are not severe problems (and have done little to hinder uptake of the mode), the existence of a system which averts these problems without considerably reducing the other advantages is clearly a useful and worthwhile prospect.
The system detailed below has been implemented but not yet tested 'on air' (details of such tests as have been performed are given later); this first draft specification has been created expressly as a prelude to live radio testing, it being a condition of the Amateur transmitting licence that, approximately put, encodings of transmitted signals must conform to a published specification in order that third parties may intercept messages.

Fundamentals:
3PSK, or 3-pole Phase Shift Keying, is unusual among keying methods in that its number of states is not a power of two.  The reason for this is simple: while each symbol encodes only a single bit, it is possible to ensure that every symbol differs from the one preceding it; in other words, there is a transition for every symbol.
The encoding used is differential; a 1 shifts the phase 'forward' 120 degrees (2pi/3 radians), while a 0 shifts it 'backward' the same amount.  Each character is first encoded with the Varicode alphabet of BPSK31, then sent as phase information in this form.  The baud rate is not defined by the specification, since the receiving end does not need to know it - it can simply detect transitions and read the direction of phase change in each case.  It is not even necessary to recover a clock signal - which means the sending station may even vary its bitrate during a transmission.  However, an implementation might choose to attempt to synchronise a clock in order to better guard against spurious symbols caused by noise; the author has not found such synchronisation necessary in his own implementation.
It would, of course, be possible to suddenly and immediately change the phase at each transition, however this would generate wide-band interference of the kind known as "key clicks"; for this reason 3PSK, like PSK31, changes the phase smoothly, in essence increasing or decreasing the frequency slightly for a fraction of the symbol duration and then returning it to its centre value.  It is necessary to ensure that only part of the symbol duration is used for this smooth transition, as the most efficacious method of receiver decoding involves checking that the phase is stable before accepting a transition.  The smoothing effect may either be integrated into the signal generation, or produced by filtering afterwards; the effect is similar in either case.

Theoretical considerations:
It must be stressed that the gains provided by 3PSK are not, mathematically speaking, 'free'; there is a drop in signal-to-noise performance due to the fact that we are only carrying 1 bit of data from a channel with 3 states (i.e., log2(3) = 1.58 bits); thus the signal-to-noise ratio is effectively worsened by about 1.5dB.  However, this can usually be made up for with only a small reduction in baud rate (and hence bandwidth), and since this is usually much smaller than the 'steps' between the various agreed-upon BPSK baud rates, 3PSK should typically outperform BPSK in most operational conditions.  For instance, if speed is simply not required, the lowest BPSK can go is typically 31.25 baud, whereas 3PSK can be operated at 5 baud or even slower (1 baud can be made to work, but requires a clever decoder), which, if suitably narrow filters are used, can reasonably be expected to punch through even in the presence of very heavy noise; certainly the gain by using less than a sixth of the bandwidth more than offsets the 1.5dB cost for the extra state.  A possible further refinement would be 5-, 9-, 17- etc. phase keying: the cost of the extra symbol is reduced in each case as it is spread over more data bits, but higher order PSK generally performs worse in noisy conditions, which may cancel out this benefit in some use cases.  Further discussion of these matters may be forthcoming in the future.

Implementation:
The author's own implementation, 3psk [PROG], consists of three separate programs: transmit, ffilter, and receive; all three are implemented in C, and are supported on Linux (although porting to other OSes should not be difficult).  ffilter and receive both use the "FFTW3" library[FFTW] for signal processing; receive uses the SDL framework for graphics.
transmit is used to produce 3PSK signals from text appearing on its standard input; the 3PSK signal is written to standard output in signed 16-bit RIFF/WAVE format, and is unfiltered (and hence still contains fairly wide sidebands), although the phase transitions are smoothed.  Command-line options may be used to set the baud rate and centre frequency, the audio sample rate, the proportion of each symbol to use for smooth transition, as well as flags such as the program's behaviour on EOF and whether the program should output in large or small blocks.  The program has two threads: one waits for input, converts it into Varicode and stores it in a buffer (an array of type 'bool'); the other periodically reads from this buffer, encodes as 3PSK, and writes the resulting audio to stdout.
ffilter is an FFT-based band-pass filter which operates in a fairly idiosyncratic way: it mixes the input up to an IF (by default, approximately 2kHz), then takes an FFT with a block length set so that the required bandwidth is covered by precisely one FFT 'bin' (the resulting wide-binned FFT is also the reason why the IF is only /approximately/ 2kHz; the actual value is chosen to lie in the centre of a bin, and is printed to stderr).  ffilter then uses the (complex) frequency domain component (the 'bin value') to modulate I and Q signals at the centre frequency.  Compared to a more traditional filter design (forward-FFT, multiplication by a transfer function, and reverse-FFT), this design saves on processing power by only requiring one FFT (the forward one) to be computed.  Command-line options may be used to set the centre frequency, bandwidth, IF, and gain (this last is purely for convenience).  ffilter reads signed 16-bit RIFF/WAVE audio on stdin, and writes the filtered signed 16-bit RIFF/WAVE audio to stdout.  The sample rate at which it operates is determined by the sample rate of the input audio.
receive reads signed 16-bit RIFF/WAVE audio on stdin and writes the decoded text to stdout; it also has a graphical display of the so-called "constellation diagram", which is helpful for tuning in signals.  It has several parameters which control the sensitivity of the decoder; there exist parameters which work at anything from super slow up to about 120 baud, although the resilience to noise can be improved at lower baud rates by using other values which do not work at the higher baud rates.  In particular, when using a narrow setting on the filter, the sensitivity must be changed.  A future version of the implementation may include a means of varying these settings during program execution.  This program works as follows: first the incoming audio is mixed up to an IF (by default, approximately 2.5kHz), and an FFT is applied; the FFT 'bin' corresponding to the IF is read (as in ffilter, the FFT block length is chosen to give a single FFT 'bin' the required bandwidth).  This generates the so-called "In-phase" and "Quadrature" components, although the mathematician would prefer to think of them as real and imaginary parts of a complex number.  These two components are then each low-pass filtered to produce the 'moving spot' on the constellation diagram.  It is the motion of this 'spot' which the decoder uses to detect transitions.  The spot's position is converted into polar co-ordinates (or, in terms of complex numbers, into modulus-argument form); if the radius is sufficiently large, the angle sufficiently far from the angle at which the previous transition was accepted, and the motion of the spot sufficiently slow (just how slow is 'sufficient' is determined by the sensitivity parameter), a new transition is accepted; the direction of the transition is determined by assuming its size is less than 180 degrees (pi radians), and the appropriate bit is appended to the data buffer.  Once two successive 0s are read (the sequence 00 marks end-of-character in Varicode), the buffer is checked against the Varicode table, and the appropriate character is output.

Testing:
As mentioned in the Rationale above, 3PSK has not yet been tested over a live radio link.  However, tests of a more local nature have been carried out.
These are the tests of version 0.1 (which did not use FFTs).
	First, transmit's output was piped (through filter) into receive, and a wide variety of parameter and baud-rate combinations were tested.  It was found that, with settings appropriately chosen, reliable and almost error-free communication could be achieved up to at least 160 baud, with somewhat less accurate decoding possible up to 300 baud.  Because the communication medium was a pipeline, there was no noise introduced by the channel, so the mode's resilience was not being tested; merely its essential operability.  A few interesting things were tried, such as running a shell through a pair of transmit-receive pairs at 120 baud.
	These tests being considered a success, the next step was to use a physical audio link.  To this end, the author devised a makeshift acoustic coupler (which consisted of a headset microphone clamped between a pair of headphones), piped transmit through filter into aplay (which plays stdin as audio), and piped arecord (which records audio to stdout) through filter into receive.  This link worked up to 120 baud and proved fairly resilient to external noise even at that high data rate (for comparison purposes, the average character of conversational English text encodes to 6.5 bits of Varicode including the separating 00 [G3PLX]; hence 120 baud Varicode is approximately 18.5 characters/second).  The author feels able to claim that these tests were also successful.
Version 0.2 of the implementation, which uses FFTs for signal processing, was then tested.
	As before, the first test was to pipe the output from transmit (through ffilter) into receive, at various baud rates.  The highest attainable baud rate has increased: stable comms can be achieved at 400 baud, although receive's settings do have to be very carefully tweaked to get a decode (and the filter bandwidth has to be set rather wide).  A further test involved an extra program, addnoise, being added into the pipeline; this simply adds a certain level of white noise to the audio stream.  The system proved fairly resilient to this noise, chiefly on account of its narrow bandwidth - but note that partial decoding was possible up to at least 120 baud even with '--mag=32' (see addnoise source), the error rate then being something like 1/6 of characters corrupted.
The author's intention is to test 3PSK 'on air', but a prerequisite for this is the provision of a friendlier user interface, as whoever operates the other end of the link will need to be able to control the software.

Conclusion:
While still highly experimental, 3PSK holds out the promise of reliable textual communication with the ability to vary the bandwidth (and hence throughput) depending on channel conditions and spectrum availability.  If successful, it will be the computer's answer to Morse Code, since the advantage of that mode over modern conversational data modes is the operator's ability to send faster or slower as required.

References:
G3PLX - "PSK31: A new radio-teletype mode with a traditional philosophy", Peter Martinez G3PLX, PDF at http://det.bi.ehu.es/~jtpjatae/pdf/p31g3plx.pdf (the article was originally published in RadCom in two parts, in the Dec 1998 and Feb 1999 issues)
FFTW - "The Fastest Fourier Transform in the West", http://www.fftw.org - your distribution should have a package called 'libfftw3' and possibly another called 'libfftw3-dev'
PROG - 3psk, the author's implementation, can be downloaded from the author's website at http://dev-null.chu.cam.ac.uk/tar/3psk.tar.gz
